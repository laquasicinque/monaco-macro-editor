
    export default [
      "socket.io-client\\build\\socket.d.ts",
      "import{Packet}from\"socket.io-parser\";import{Manager}from\"./manager\";import{DefaultEventsMap,EventNames,EventParams,EventsMap,StrictEventEmitter}from\"./typed-events\";export interface SocketOptions{/**\n * the authentication payload sent when connecting to the Namespace\n */\nauth:{[key:string]:any;}|((cb:(data:object)=>void)=>void);}interface SocketReservedEvents{connect:()=>void;connect_error:(err:Error)=>void;disconnect:(reason:Socket.DisconnectReason)=>void;}export declare class Socket<ListenEvents extends EventsMap=DefaultEventsMap,EmitEvents extends EventsMap=ListenEvents>extends StrictEventEmitter<ListenEvents,EmitEvents,SocketReservedEvents>{readonly io:Manager<ListenEvents,EmitEvents>;id:string;connected:boolean;disconnected:boolean;auth:{[key:string]:any;}|((cb:(data:object)=>void)=>void);receiveBuffer:Array<ReadonlyArray<any>>;sendBuffer:Array<Packet>;private readonly nsp;private ids;private acks;private flags;private subs?;private _anyListeners;/**\n * `Socket` constructor.\n *\n * @public\n */constructor(io:Manager,nsp:string,opts?:Partial<SocketOptions>);/**\n * Subscribe to open, close and packet events\n *\n * @private\n */private subEvents;/**\n * Whether the Socket will try to reconnect when its Manager connects or reconnects\n */get active():boolean;/**\n * \"Opens\" the socket.\n *\n * @public\n */\nconnect():this;/**\n * Alias for connect()\n */\nopen():this;/**\n * Sends a `message` event.\n *\n * @return self\n * @public\n */\nsend(...args:any[]):this;/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @return self\n * @public\n */\nemit<Ev extends EventNames<EmitEvents>>(ev:Ev,...args:EventParams<EmitEvents,Ev>):this;/**\n * Sends a packet.\n *\n * @param packet\n * @private\n */private packet;/**\n * Called upon engine `open`.\n *\n * @private\n */private onopen;/**\n * Called upon engine or manager `error`.\n *\n * @param err\n * @private\n */private onerror;/**\n * Called upon engine `close`.\n *\n * @param reason\n * @private\n */private onclose;/**\n * Called with socket packet.\n *\n * @param packet\n * @private\n */private onpacket;/**\n * Called upon a server event.\n *\n * @param packet\n * @private\n */private onevent;private emitEvent;/**\n * Produces an ack callback to emit with an event.\n *\n * @private\n */private ack;/**\n * Called upon a server acknowlegement.\n *\n * @param packet\n * @private\n */private onack;/**\n * Called upon server connect.\n *\n * @private\n */private onconnect;/**\n * Emit buffered events (received and emitted).\n *\n * @private\n */private emitBuffered;/**\n * Called upon server disconnect.\n *\n * @private\n */private ondisconnect;/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @private\n */private destroy;/**\n * Disconnects the socket manually.\n *\n * @return self\n * @public\n */\ndisconnect():this;/**\n * Alias for disconnect()\n *\n * @return self\n * @public\n */\nclose():this;/**\n * Sets the compress flag.\n *\n * @param compress - if `true`, compresses the sending data\n * @return self\n * @public\n */\ncompress(compress:boolean):this;/**\n * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n * ready to send messages.\n *\n * @returns self\n * @public\n */get volatile():this;/**\n * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n * callback.\n *\n * @param listener\n * @public\n */\nonAny(listener:(...args:any[])=>void):this;/**\n * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n * callback. The listener is added to the beginning of the listeners array.\n *\n * @param listener\n * @public\n */\nprependAny(listener:(...args:any[])=>void):this;/**\n * Removes the listener that will be fired when any event is emitted.\n *\n * @param listener\n * @public\n */\noffAny(listener?:(...args:any[])=>void):this;/**\n * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n * e.g. to remove listeners.\n *\n * @public\n */\nlistenersAny():((...args:any[])=>void)[];}export declare namespace Socket{type DisconnectReason=\"io server disconnect\"|\"io client disconnect\"|\"ping timeout\"|\"transport close\"|\"transport error\";}export{};"
    ]
  