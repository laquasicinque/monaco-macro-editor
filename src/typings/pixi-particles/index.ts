
    export default [
      "pixi-particles\\index.d.ts",
      "import{Circle,Container,DisplayObject,Point,Rectangle,Renderer,Sprite,Texture}from'pixi.js';export interface BasicPoint{x:number;y:number;}export interface Segment{p1:BasicPoint;p2:BasicPoint;l:number;}/**\r * Chain of line segments for generating spawn positions.\r */export declare class PolygonalChain{/**\r * List of segment objects in the chain.\r */private segments;/**\r * Total length of all segments of the chain.\r */private totalLength;/**\r * Total length of segments up to and including the segment of the same index.\r * Used for weighted random selection of segment.\r */private countingLengths;/**\r * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r */constructor(data:BasicPoint[]|BasicPoint[][]);/**\r * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r */private init;/**\r * Gets a random point in the chain.\r * @param out The point to store the selected position in.\r */\ngetRandomPoint(out:Point):void;}export interface EmitterConfig{alpha?:ValueList<number>;speed?:ValueList<number>;minimumSpeedMultiplier?:number;maxSpeed?:number;acceleration?:{x:number;y:number;};scale?:ValueList<number>;minimumScaleMultiplier?:number;color?:ValueList<string>;startRotation?:RandNumber;noRotation?:boolean;rotationSpeed?:RandNumber;rotationAcceleration?:number;lifetime:RandNumber;blendMode?:string;ease?:SimpleEase|EaseSegment[];extraData?:any;particlesPerWave?:number;/**\r * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\r * tends to be too strict for random object creation.\r */\nspawnType?:string;spawnRect?:{x:number;y:number;w:number;h:number;};spawnCircle?:{x:number;y:number;r:number;minR?:number;};particleSpacing?:number;angleStart?:number;spawnPolygon?:BasicPoint[]|BasicPoint[][];frequency:number;spawnChance?:number;emitterLifetime?:number;maxParticles?:number;addAtBack?:boolean;pos:{x:number;y:number;};emit?:boolean;autoUpdate?:boolean;orderedArt?:boolean;}export interface RandNumber{max:number;min:number;}export interface BasicTweenable<T>{start:T;end:T;}export interface OldEmitterConfig{alpha?:BasicTweenable<number>;speed?:BasicTweenable<number>&{minimumSpeedMultiplier?:number;};maxSpeed?:number;acceleration?:{x:number;y:number;};scale?:BasicTweenable<number>&{minimumScaleMultiplier?:number;};color?:BasicTweenable<string>;startRotation?:RandNumber;noRotation?:boolean;rotationSpeed?:RandNumber;rotationAcceleration?:number;lifetime:RandNumber;blendMode?:string;ease?:SimpleEase|EaseSegment[];extraData?:any;particlesPerWave?:number;/**\r * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\r * tends to be too strict for random object creation.\r */\nspawnType?:string;spawnRect?:{x:number;y:number;w:number;h:number;};spawnCircle?:{x:number;y:number;r:number;minR?:number;};particleSpacing?:number;angleStart?:number;spawnPolygon?:BasicPoint[]|BasicPoint[][];frequency:number;spawnChance?:number;emitterLifetime?:number;maxParticles?:number;addAtBack?:boolean;pos:{x:number;y:number;};emit?:boolean;autoUpdate?:boolean;orderedArt?:boolean;}export interface ValueStep<T>{value:T;time:number;}export interface ValueList<T>{list:ValueStep<T>[];isStepped?:boolean;ease?:SimpleEase|EaseSegment[];}/**\r * A single node in a PropertyList.\r */export declare class PropertyNode<V>{/**\r * Value for the node.\r */\nvalue:V;/**\r * Time value for the node. Between 0-1.\r */\ntime:number;/**\r * The next node in line.\r */\nnext:PropertyNode<V>;/**\r * If this is the first node in the list, controls if the entire list is stepped or not.\r */\nisStepped:boolean;ease:SimpleEase;/**\r * @param value The value for this node\r * @param time The time for this node, between 0-1\r * @param [ease] Custom ease for this list. Only relevant for the first node.\r */constructor(value:V,time:number,ease?:SimpleEase|EaseSegment[]);/**\r * Creates a list of property values from a data object {list, isStepped} with a list of objects in\r * the form {value, time}. Alternatively, the data object can be in the deprecated form of\r * {start, end}.\r * @param data The data for the list.\r * @param data.list The array of value and time objects.\r * @param data.isStepped If the list is stepped rather than interpolated.\r * @param data.ease Custom ease for this list.\r * @return The first node in the list\r */static createList<T extends(string|number)>(data:ValueList<T>|BasicTweenable<T>):PropertyNode<T extends string?Color:T>;}export declare function GetTextureFromString(s:string):Texture;export interface Color{r:number;g:number;b:number;a?:number;}export interface EaseSegment{cp:number;s:number;e:number;}export declare type SimpleEase=(time:number)=>number;/**\r * Contains helper functions for particles and emitters to use.\r */export declare namespace ParticleUtils{/**\r * If errors and warnings should be logged within the library.\r */const verbose=false;const DEG_TO_RADS:number;/**\r * Rotates a point by a given angle.\r * @param angle The angle to rotate by in degrees\r * @param p The point to rotate around 0,0.\r */function rotatePoint(angle:number,p:Point):void;/**\r * Combines separate color components (0-255) into a single uint color.\r * @param r The red value of the color\r * @param g The green value of the color\r * @param b The blue value of the color\r * @return The color in the form of 0xRRGGBB\r */function combineRGBComponents(r:number,g:number,b:number):number;/**\r * Reduces the point to a length of 1.\r * @param point The point to normalize\r */function normalize(point:Point):void;/**\r * Multiplies the x and y values of this point by a value.\r * @param point The point to scaleBy\r * @param value The value to scale by.\r */function scaleBy(point:Point,value:number):void;/**\r * Returns the length (or magnitude) of this point.\r * @param point The point to measure length\r * @return The length of this point.\r */function length(point:Point):number;/**\r * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\r * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\r * {r, g, b, (a)}.\r * @param color The input color string.\r * @param output An object to put the output in. If omitted, a new object is created.\r * @return The object with r, g, and b properties, possibly with an a property.\r */function hexToRGB(color:string,output?:Color):Color;/**\r * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\r * by the related tool at http://www.greensock.com/customease/.\r * @param segments An array of segments, as created by\r * http://www.greensock.com/customease/.\r * @return A function that calculates the percentage of change at\r *                    a given point in time (0-1 inclusive).\r */function generateEase(segments:EaseSegment[]):SimpleEase;/**\r * Gets a blend mode, ensuring that it is valid.\r * @param name The name of the blend mode to get.\r * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\r */function getBlendMode(name:string):number;/**\r * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\r * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\r * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\r * @param list The list of data to convert.\r * @param [numSteps=10] The number of steps to use.\r * @return The blend mode as specified in the PIXI.blendModes enumeration.\r */function createSteppedGradient(list:ValueStep<string>[],numSteps?:number):PropertyNode<Color>;}export interface ParticleConstructor{new(emitter:Emitter):Particle;}/**\r * A particle emitter.\r */export declare class Emitter{/**\r * The constructor used to create new particles. The default is\r * the built in particle class.\r */protected _particleConstructor:typeof Particle;/**\r * An array of PIXI Texture objects.\r */\nparticleImages:any[];/**\r * The first node in the list of alpha values for all particles.\r */\nstartAlpha:PropertyNode<number>;/**\r * The first node in the list of speed values of all particles.\r */\nstartSpeed:PropertyNode<number>;/**\r * A minimum multiplier for the speed of a particle at all stages of its life. A value between\r * minimumSpeedMultiplier and 1 is randomly generated for each particle.\r */\nminimumSpeedMultiplier:number;/**\r * Acceleration to apply to particles. Using this disables\r * any interpolation of particle speed. If the particles do\r * not have a rotation speed, then they will be rotated to\r * match the direction of travel.\r */\nacceleration:Point;/**\r * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r * will disable the maximum speed.\r */\nmaxSpeed:number;/**\r * The first node in the list of scale values of all particles.\r */\nstartScale:PropertyNode<number>;/**\r * A minimum multiplier for the scale of a particle at all stages of its life. A value between\r * minimumScaleMultiplier and 1 is randomly generated for each particle.\r */\nminimumScaleMultiplier:number;/**\r * The first node in the list of  color values of all particles, as red, green, and blue\r * uints from 0-255.\r */\nstartColor:PropertyNode<Color>;/**\r * The minimum lifetime for a particle, in seconds.\r */\nminLifetime:number;/**\r * The maximum lifetime for a particle, in seconds.\r */\nmaxLifetime:number;/**\r * The minimum start rotation for a particle, in degrees. This value\r * is ignored if the spawn type is \"burst\" or \"arc\".\r */\nminStartRotation:number;/**\r * The maximum start rotation for a particle, in degrees. This value\r * is ignored if the spawn type is \"burst\" or \"arc\".\r */\nmaxStartRotation:number;/**\r * If no particle rotation should occur. Starting rotation will still\r * affect the direction in which particles move. If the rotation speed\r * is set, then this will be ignored.\r */\nnoRotation:boolean;/**\r * The minimum rotation speed for a particle, in degrees per second.\r * This only visually spins the particle, it does not change direction\r * of movement.\r */\nminRotationSpeed:number;/**\r * The maximum rotation speed for a particle, in degrees per second.\r * This only visually spins the particle, it does not change direction\r * of movement.\r */\nmaxRotationSpeed:number;/**\r * The Acceleration of rotation (angular acceleration) for a particle, in degrees per second.\r */\nrotationAcceleration:number;/**\r * The blend mode for all particles, as named by PIXI.blendModes.\r */\nparticleBlendMode:number;/**\r * An easing function for nonlinear interpolation of values. Accepts a single\r * parameter of time as a value from 0-1, inclusive. Expected outputs are values\r * from 0-1, inclusive.\r */\ncustomEase:SimpleEase;/**\r *\tExtra data for use in custom particles. The emitter doesn't look inside, but\r *\tpasses it on to the particle to use in init().\r */\nextraData:any;/**\r * Time between particle spawns in seconds.\r */protected _frequency:number;/**\r * Chance that a particle will be spawned on each opportunity to spawn one.\r * 0 is 0%, 1 is 100%.\r */\nspawnChance:number;/**\r * Maximum number of particles to keep alive at a time. If this limit\r * is reached, no more particles will spawn until some have died.\r */\nmaxParticles:number;/**\r * The amount of time in seconds to emit for before setting emit to false.\r * A value of -1 is an unlimited amount of time.\r */\nemitterLifetime:number;/**\r * Position at which to spawn particles, relative to the emitter's owner's origin.\r * For example, the flames of a rocket travelling right might have a spawnPos\r * of {x:-50, y:0}.\r * to spawn at the rear of the rocket.\r * To change this, use updateSpawnPos().\r */\nspawnPos:Point;/**\r * How the particles will be spawned. Valid types are \"point\", \"rectangle\",\r * \"circle\", \"burst\", \"ring\".\r */\nspawnType:string;/**\r * A reference to the emitter function specific to the spawn type.\r */protected _spawnFunc:(p:Particle,emitPosX:number,emitPosY:number,i?:number)=>void;/**\r * A rectangle relative to spawnPos to spawn particles inside if the spawn type is \"rect\".\r */\nspawnRect:Rectangle;/**\r * A polygon relative to spawnPos to spawn particles on the chain if the spawn type is \"polygonalChain\".\r */\nspawnPolygonalChain:PolygonalChain;/**\r * A circle relative to spawnPos to spawn particles inside if the spawn type is \"circle\".\r */\nspawnCircle:Circle&{minRadius:number;};/**\r * Number of particles to spawn time that the frequency allows for particles to spawn.\r */\nparticlesPerWave:number;/**\r * Spacing between particles in a burst. 0 gives a random angle for each particle.\r */\nparticleSpacing:number;/**\r * Angle at which to start spawning particles in a burst.\r */\nangleStart:number;/**\r * Rotation of the emitter or emitter's owner in degrees. This is added to\r * the calculated spawn angle.\r * To change this, use rotate().\r */protected rotation:number;/**\r * The world position of the emitter's owner, to add spawnPos to when\r * spawning particles. To change this, use updateOwnerPos().\r */protected ownerPos:Point;/**\r * The origin + spawnPos in the previous update, so that the spawn position\r * can be interpolated to space out particles better.\r */protected _prevEmitterPos:Point;/**\r * If _prevEmitterPos is valid, to prevent interpolation on the first update\r */protected _prevPosIsValid:boolean;/**\r * If either ownerPos or spawnPos has changed since the previous update.\r */protected _posChanged:boolean;/**\r * The container to add particles to.\r */protected _parent:Container;/**\r * If particles should be added at the back of the display list instead of the front.\r */\naddAtBack:boolean;/**\r * The current number of active particles.\r */\nparticleCount:number;/**\r * If particles should be emitted during update() calls. Setting this to false\r * stops new particles from being created, but allows existing ones to die out.\r */protected _emit:boolean;/**\r * The timer for when to spawn particles in seconds, where numbers less\r * than 0 mean that particles should be spawned.\r */protected _spawnTimer:number;/**\r * The life of the emitter in seconds.\r */protected _emitterLife:number;/**\r * The particles that are active and on the display list. This is the first particle in a\r * linked list.\r */protected _activeParticlesFirst:Particle;/**\r * The particles that are active and on the display list. This is the last particle in a\r * linked list.\r */protected _activeParticlesLast:Particle;/**\r * The particles that are not currently being used. This is the first particle in a\r * linked list.\r */protected _poolFirst:Particle;/**\r * The original config object that this emitter was initialized with.\r */protected _origConfig:any;/**\r * The original particle image data that this emitter was initialized with.\r */protected _origArt:any;/**\r * If the update function is called automatically from the shared ticker.\r * Setting this to false requires calling the update function manually.\r */protected _autoUpdate:boolean;/**\r * A number keeping index of currently applied image. Used to emit arts in order.\r */protected _currentImageIndex:number;/**\r * If the emitter should destroy itself when all particles have died out. This is set by\r * playOnceAndDestroy();\r */protected _destroyWhenComplete:boolean;/**\r * A callback for when all particles have died out. This is set by\r * playOnceAndDestroy() or playOnce();\r */protected _completeCallback:()=>void;/**\r * @param particleParent The container to add the particles to.\r * @param particleImages A texture or array of textures to use\r *                       for the particles. Strings will be turned\r *                       into textures via Texture.fromImage().\r * @param config A configuration object containing settings for the emitter.\r * @param config.emit If config.emit is explicitly passed as false, the\r *                    Emitter will start disabled.\r * @param config.autoUpdate If config.autoUpdate is explicitly passed as\r *                          true, the Emitter will automatically call\r *                          update via the PIXI shared ticker.\r */constructor(particleParent:Container,particleImages:any,config:EmitterConfig|OldEmitterConfig);/**\r * If the emitter is using particle art in order as provided in `particleImages`.\r * Effective only when `particleImages` has multiple art options.\r * This is particularly useful ensuring that each art shows up once, in case you need to emit a body in an order.\r * For example: dragon - [Head, body1, body2, ..., tail]\r */\norderedArt:boolean;/**\r * Time between particle spawns in seconds. If this value is not a number greater than 0,\r * it will be set to 1 (particle per second) to prevent infinite loops.\r */\nfrequency:number;/**\r * The constructor used to create new particles. The default is\r * the built in Particle class. Setting this will dump any active or\r * pooled particles, if the emitter has already been used.\r */\nparticleConstructor:typeof Particle;/**\r * The container to add particles to. Settings this will dump any active particles.\r */\nparent:Container;/**\r * Sets up the emitter based on the config settings.\r * @param art A texture or array of textures to use for the particles.\r * @param config A configuration object containing settings for the emitter.\r */\ninit(art:any,config:EmitterConfig|OldEmitterConfig):void;/**\r * Sets up additional parameters to the emitter from config settings.\r * Using for parsing additional parameters on classes that extend from Emitter\r * @param art A texture or array of textures to use for the particles.\r * @param config A configuration object containing settings for the emitter.\r */protected initAdditional(art:any,config:EmitterConfig|OldEmitterConfig):void;/**\r * Parsing emitter spawn type from config settings.\r * Place for override and add new kind of spawn type\r * @param config A configuration object containing settings for the emitter.\r */protected parseSpawnType(config:EmitterConfig|OldEmitterConfig):void;/**\r * Recycles an individual particle. For internal use only.\r * @param particle The particle to recycle.\r * @internal\r */\nrecycle(particle:Particle):void;/**\r * Sets the rotation of the emitter to a new value.\r * @param newRot The new rotation, in degrees.\r */\nrotate(newRot:number):void;/**\r * Changes the spawn position of the emitter.\r * @param x The new x value of the spawn position for the emitter.\r * @param y The new y value of the spawn position for the emitter.\r */\nupdateSpawnPos(x:number,y:number):void;/**\r * Changes the position of the emitter's owner. You should call this if you are adding\r * particles to the world container that your emitter's owner is moving around in.\r * @param x The new x value of the emitter's owner.\r * @param y The new y value of the emitter's owner.\r */\nupdateOwnerPos(x:number,y:number):void;/**\r * Prevents emitter position interpolation in the next update.\r * This should be used if you made a major position change of your emitter's owner\r * that was not normal movement.\r */\nresetPositionTracking():void;/**\r * If particles should be emitted during update() calls. Setting this to false\r * stops new particles from being created, but allows existing ones to die out.\r */\nemit:boolean;/**\r * If the update function is called automatically from the shared ticker.\r * Setting this to false requires calling the update function manually.\r */\nautoUpdate:boolean;/**\r * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\r * when particle emission is complete.\r * @param callback Callback for when emission is complete (all particles have died off)\r */\nplayOnceAndDestroy(callback?:()=>void):void;/**\r * Starts emitting particles and optionally calls a callback when particle emission is complete.\r * @param callback Callback for when emission is complete (all particles have died off)\r */\nplayOnce(callback?:()=>void):void;/**\r * Updates all particles spawned by this emitter and emits new ones.\r * @param delta Time elapsed since the previous frame, in __seconds__.\r */\nupdate(delta:number):void;/**\r * Set additional properties to new particle.\r * Using on classes that extend from Emitter\r * @param p The particle\r */protected applyAdditionalProperties(p:Particle):void;/**\r * Positions a particle for a point type emitter.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave. Not used for this function.\r */protected _spawnPoint(p:Particle,emitPosX:number,emitPosY:number):void;/**\r * Positions a particle for a rectangle type emitter.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave. Not used for this function.\r */protected _spawnRect(p:Particle,emitPosX:number,emitPosY:number):void;/**\r * Positions a particle for a circle type emitter.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave. Not used for this function.\r */protected _spawnCircle(p:Particle,emitPosX:number,emitPosY:number):void;/**\r * Positions a particle for a ring type emitter.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave. Not used for this function.\r */protected _spawnRing(p:Particle,emitPosX:number,emitPosY:number):void;/**\r * Positions a particle for polygonal chain.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave. Not used for this function.\r */protected _spawnPolygonalChain(p:Particle,emitPosX:number,emitPosY:number):void;/**\r * Positions a particle for a burst type emitter.\r * @param p The particle to position and rotate.\r * @param emitPosX The emitter's x position\r * @param emitPosY The emitter's y position\r * @param i The particle number in the current wave.\r */protected _spawnBurst(p:Particle,emitPosX:number,emitPosY:number,i:number):void;/**\r * Kills all active particles immediately.\r */\ncleanup():void;/**\r * Destroys the emitter and all of its particles.\r */\ndestroy():void;}/**\r * Singly linked list container for keeping track of interpolated properties for particles.\r * Each Particle will have one of these for each interpolated property.\r */export declare class PropertyList<V>{/**\r * The current property node in the linked list.\r */\ncurrent:PropertyNode<V>;/**\r * The next property node in the linked list. Stored separately for slightly less variable\r * access.\r */\nnext:PropertyNode<V>;/**\r * Calculates the correct value for the current interpolation value. This method is set in\r * the reset() method.\r * @param lerp The interpolation value from 0-1.\r * @return The interpolated value. Colors are converted to the hex value.\r */\ninterpolate:(lerp:number)=>number;/**\r * A custom easing method for this list.\r * @param lerp The interpolation value from 0-1.\r * @return The eased value, also from 0-1.\r */\nease:SimpleEase;/**\r * If this list manages colors, which requires a different method for interpolation.\r */private isColor;/**\r * @param isColor If this list handles color values\r */constructor(isColor?:boolean);/**\r * Resets the list for use.\r * @param first The first node in the list.\r * @param first.isStepped If the values should be stepped instead of interpolated linearly.\r */\nreset(first:PropertyNode<V>):void;}/** Interface for a child of a LinkedListContainer (has the prev/next properties added) */export interface LinkedListChild extends DisplayObject{nextChild:LinkedListChild|null;prevChild:LinkedListChild|null;}/**\r * A semi-experimental Container that uses a doubly linked list to manage children instead of an\r * array. This means that adding/removing children often is not the same performance hit that\r * it would to be continually pushing/splicing.\r * However, this is primarily intended to be used for heavy particle usage, and may not handle\r * edge cases well if used as a complete Container replacement.\r */export declare class LinkedListContainer extends Container{private _firstChild;private _lastChild;private _childCount;readonly firstChild:LinkedListChild;readonly lastChild:LinkedListChild;readonly childCount:number;addChild<T extends DisplayObject[]>(...children:T):T[0];addChildAt<T extends DisplayObject>(child:T,index:number):T;/**\r * Adds a child to the container to be rendered below another child.\r *\r * @param child The child to add\r * @param relative - The current child to add the new child relative to.\r * @return The child that was added.\r */\naddChildBelow<T extends DisplayObject>(child:T,relative:DisplayObject):T;/**\r * Adds a child to the container to be rendered above another child.\r *\r * @param child The child to add\r * @param relative - The current child to add the new child relative to.\r * @return The child that was added.\r */\naddChildAbove<T extends DisplayObject>(child:T,relative:DisplayObject):T;swapChildren(child:DisplayObject,child2:DisplayObject):void;getChildIndex(child:DisplayObject):number;setChildIndex(child:DisplayObject,index:number):void;removeChild<T extends DisplayObject[]>(...children:T):T[0];getChildAt(index:number):DisplayObject;removeChildAt(index:number):DisplayObject;removeChildren(beginIndex?:number,endIndex?:number):DisplayObject[];/**\r * Updates the transform on all children of this container for rendering.\r * Copied from and overrides PixiJS v5 method (v4 method is identical)\r */\nupdateTransform():void;/**\r * Recalculates the bounds of the container.\r * Copied from and overrides PixiJS v5 method (v4 method is identical)\r */\ncalculateBounds():void;/**\r * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method\r */\ngetLocalBounds(rect?:Rectangle,skipChildrenUpdate?:boolean):Rectangle;/**\r * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method\r */\nrender(renderer:Renderer):void;/**\r * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method\r */protected renderAdvanced(renderer:Renderer):void;/**\r * Renders the object using the WebGL renderer. Copied from and overrides PixiJS V4 method.\r */\nrenderWebGL(renderer:any):void;/**\r * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS V4 method.\r */private renderAdvancedWebGL;/**\r * Renders the object using the Canvas renderer. Copied from and overrides PixiJS V4 method or Canvas mixin in V5.\r */\nrenderCanvas(renderer:any):void;}/**\r * An individual particle image. You shouldn't have to deal with these.\r */export declare class Particle extends Sprite implements LinkedListChild{/**\r * The emitter that controls this particle.\r */\nemitter:Emitter;/**\r * The velocity of the particle. Speed may change, but the angle also\r * contained in velocity is constant.\r */\nvelocity:Point;/**\r * The maximum lifetime of this particle, in seconds.\r */\nmaxLife:number;/**\r * The current age of the particle, in seconds.\r */\nage:number;/**\r * A simple easing function to be applied to all properties that\r * are being interpolated.\r */\nease:SimpleEase;/**\r * Extra data that the emitter passes along for custom particles.\r */\nextraData:any;/**\r * The alpha of the particle throughout its life.\r */\nalphaList:PropertyList<number>;/**\r * The speed of the particle throughout its life.\r */\nspeedList:PropertyList<number>;/**\r * A multiplier from 0-1 applied to the speed of the particle at all times.\r */\nspeedMultiplier:number;/**\r * Acceleration to apply to the particle.\r */\nacceleration:Point;/**\r * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r * will disable the maximum speed.\r */\nmaxSpeed:number;/**\r * Speed at which the particle rotates, in radians per second.\r */\nrotationSpeed:number;/**\r * Acceleration of rotation (angular acceleration) to apply to the particle.\r */\nrotationAcceleration:number;/**\r * If particle rotation is locked, preventing rotation from occurring due\r * to directional changes.\r */\nnoRotation:boolean;/**\r * The scale of the particle throughout its life.\r */\nscaleList:PropertyList<number>;/**\r * A multiplier from 0-1 applied to the scale of the particle at all times.\r */\nscaleMultiplier:number;/**\r * The tint of the particle throughout its life.\r */\ncolorList:PropertyList<Color>;/**\r * A reference to init, so that subclasses can access it without the penalty of Function.call()\r */protected Particle_init:typeof Particle.prototype.init;/**\r * A reference to update so that subclasses can access the original without the overhead\r * of Function.call().\r * @param delta Time elapsed since the previous frame, in __seconds__.\r * @return The standard interpolation multiplier (0-1) used for all relevant particle\r *                   properties. A value of -1 means the particle died of old age instead.\r */protected Particle_update:typeof Particle.prototype.update;protected Particle_destroy:typeof Particle.prototype.destroy;protected Sprite_destroy:typeof Sprite.prototype.destroy;/**\r * If alpha should be interpolated at all.\r */protected _doAlpha:boolean;/**\r * If scale should be interpolated at all.\r */protected _doScale:boolean;/**\r * If speed should be interpolated at all.\r */protected _doSpeed:boolean;/**\r * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\r * and _doSpeed gets priority.\r */protected _doAcceleration:boolean;/**\r * If color should be interpolated at all.\r */protected _doColor:boolean;/**\r * If normal movement should be handled. Subclasses wishing to override movement\r * can set this to false in init().\r */protected _doNormalMovement:boolean;/**\r * One divided by the max life of the particle, saved for slightly faster math.\r */private _oneOverLife;/**\r * Reference to the next particle in the list.\r */\nnext:Particle;/**\r * Reference to the previous particle in the list.\r */\nprev:Particle;prevChild:LinkedListChild;nextChild:LinkedListChild;/**\r * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\r */constructor(emitter:Emitter);/**\r * Initializes the particle for use, based on the properties that have to\r * have been set already on the particle.\r */\ninit():void;/**\r * Sets the texture for the particle. This can be overridden to allow\r * for an animated particle.\r * @param art The texture to set.\r */\napplyArt(art:any):void;/**\r * Updates the particle.\r * @param delta Time elapsed since the previous frame, in __seconds__.\r * @return The standard interpolation multiplier (0-1) used for all\r *         relevant particle properties. A value of -1 means the particle\r *         died of old age instead.\r */\nupdate(delta:number):number;/**\r * Kills the particle, removing it from the display list\r * and telling the emitter to recycle it.\r */\nkill():void;/**\r * Destroys the particle, removing references and preventing future use.\r */\ndestroy():void;/**\r * Checks over the art that was passed to the Emitter's init() function, to do any special\r * modifications to prepare it ahead of time.\r * @param art The array of art data. For Particle, it should be an array of\r *            Textures. Any strings in the array will be converted to\r *            Textures via Texture.from().\r * @return The art, after any needed modifications.\r */static parseArt(art:any[]):any[];/**\r * Parses extra emitter data to ensure it is set up for this particle class.\r * Particle does nothing to the extra data.\r * @param extraData The extra data from the particle config.\r * @return The parsed extra data.\r */static parseData(extraData:any):any;}/**\r * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\r * \"5x + 3\".\r * To use this class, the particle config must have a \"path\" string in the\r * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\r * speed settings of the particle). It may have numbers, parentheses, the four basic\r * operations, and the following Math functions or properties (without the preceding \"Math.\"):\r * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\r * \"acos\", \"atan\", \"atan2\", \"log\".\r * The overall movement of the particle and the expression value become x and y positions for\r * the particle, respectively. The final position is rotated by the spawn rotation/angle of\r * the particle.\r *\r * Some example paths:\r *\r * \t\"sin(x/10) * 20\" // A sine wave path.\r * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\r * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\r */export declare class PathParticle extends Particle{/**\r * The function representing the path the particle should take.\r */\npath:Function;/**\r * The initial rotation in degrees of the particle, because the direction of the path\r * is based on that.\r */\ninitialRotation:number;/**\r * The initial position of the particle, as all path movement is added to that.\r */\ninitialPosition:Point;/**\r * Total single directional movement, due to speed.\r */\nmovement:number;/**\r * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\r */constructor(emitter:Emitter);/**\r * Initializes the particle for use, based on the properties that have to\r * have been set already on the particle.\r */\ninit():void;/**\r * Updates the particle.\r * @param delta Time elapsed since the previous frame, in __seconds__.\r */\nupdate(delta:number):number;/**\r * Destroys the particle, removing references and preventing future use.\r */\ndestroy():void;/**\r * Checks over the art that was passed to the Emitter's init() function, to do any special\r * modifications to prepare it ahead of time. This just runs Particle.parseArt().\r * @param art The array of art data. For Particle, it should be an array of\r *            Textures. Any strings in the array will be converted to\r *            Textures via Texture.fromImage().\r * @return The art, after any needed modifications.\r */static parseArt(art:(Texture|string)[]):Texture[];/**\r * Parses extra emitter data to ensure it is set up for this particle class.\r * PathParticle checks for the existence of path data, and parses the path data for use\r * by particle instances.\r * @param extraData The extra data from the particle config.\r * @return The parsed extra data.\r */static parseData(extraData:{path:string;}):any;}export interface ParsedAnimatedParticleArt{textures:Texture[];duration:number;framerate:number;loop:boolean;}export interface AnimatedParticleArt{framerate:'matchLife'|number;loop?:boolean;textures:(string|Texture|{texture:string|Texture;count:number;})[];}/**\r * An individual particle image with an animation. Art data passed to the emitter must be\r * formatted in a particular way for AnimatedParticle to be able to handle it:\r *\r * ```typescript\r * {\r *     //framerate is required. It is the animation speed of the particle in frames per\r *     //second.\r *     //A value of \"matchLife\" causes the animation to match the lifetime of an individual\r *     //particle, instead of at a constant framerate. This causes the animation to play\r *     //through one time, completing when the particle expires.\r *     framerate: 6,\r *     //loop is optional, and defaults to false.\r *     loop: true,\r *     //textures is required, and can be an array of any (non-zero) length.\r *     textures: [\r *         //each entry represents a single texture that should be used for one or more\r *         //frames. Any strings will be converted to Textures with Texture.from().\r *         //Instances of PIXI.Texture will be used directly.\r *         \"animFrame1.png\",\r *         //entries can be an object with a 'count' property, telling AnimatedParticle to\r *         //use that texture for 'count' frames sequentially.\r *         {\r *             texture: \"animFrame2.png\",\r *             count: 3\r *         },\r *         \"animFrame3.png\"\r *     ]\r * }\r * ```\r */export declare class AnimatedParticle extends Particle{/**\r * Texture array used as each frame of animation, similarly to how MovieClip works.\r */private textures;/**\r * Duration of the animation, in seconds.\r */private duration;/**\r * Animation framerate, in frames per second.\r */private framerate;/**\r * Animation time elapsed, in seconds.\r */private elapsed;/**\r * If this particle animation should loop.\r */private loop;/**\r * @param emitter The emitter that controls this AnimatedParticle.\r */constructor(emitter:Emitter);/**\r * Initializes the particle for use, based on the properties that have to\r * have been set already on the particle.\r */\ninit():void;/**\r * Sets the textures for the particle.\r * @param art An array of PIXI.Texture objects for this animated particle.\r */\napplyArt(art:ParsedAnimatedParticleArt):void;/**\r * Updates the particle.\r * @param delta Time elapsed since the previous frame, in __seconds__.\r */\nupdate(delta:number):number;/**\r * Destroys the particle, removing references and preventing future use.\r */\ndestroy():void;/**\r * Checks over the art that was passed to the Emitter's init() function, to do any special\r * modifications to prepare it ahead of time.\r * @param art The array of art data, properly formatted for AnimatedParticle.\r * @return The art, after any needed modifications.\r */static parseArt(art:AnimatedParticleArt[]):any;}export{};"
    ]
  