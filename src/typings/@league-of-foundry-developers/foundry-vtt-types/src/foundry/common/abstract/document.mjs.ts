
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\common\\abstract\\document.mjs.d.ts",
      "import{BaseUser}from'../documents.mjs';import DatabaseBackend from'./backend.mjs';import{AnyDocumentData}from'./data.mjs';import{ConfiguredDocumentClass,DocumentConstructor,ToObjectFalseType,DocumentType,ConstructorDataType}from'../../../types/helperTypes';import EmbeddedCollection from'./embedded-collection.mjs';type ParentType<T extends Document<any,any>>=T extends Document<any,infer U>?U:never;export type ContextType<T extends Document<any,any>>=Context<ParentType<T>>;export type DocumentDataType<T extends Document<any,any>>=T extends Document<infer U,any>?U:never;/**\n * The abstract base class shared by both client and server-side which defines the model for a single document type.\n */declare abstract class Document<\nConcreteDocumentData extends AnyDocumentData,Parent extends Document<any,any>|null=null>{/**\n * Create a new Document by providing an initial data object.\n * @param data    - Initial data provided to construct the Document\n * @param context - Additional parameters which define Document context\n */constructor(data?:ConstructorDataType<ConcreteDocumentData>,context?:Context<Parent>);/**\n * An immutable reverse-reference to the parent Document to which this embedded Document belongs.\n */readonly parent:Parent|null;/**\n * An immutable reference to a containing Compendium collection to which this Document belongs.\n */readonly pack:string|null;/**\n * The base data object for this Document which persists both the original source and any derived data.\n */readonly data:ConcreteDocumentData;/**\n * Perform one-time initialization tasks which only occur when the Document is first constructed.\n */protected _initialize():void;/**\n * Every document must define an object which represents its data schema.\n * This must be a subclass of the DocumentData interface.\n *\n * @remarks\n * This method is abstract and needs to be implemented by inheriting classes.\n */static get schema():ConstructorOf<AnyDocumentData>;/**\n * Default metadata which applies to each instance of this Document type.\n * @defaultValue\n * ```typescript\n * {\n *   name: \"Document\",\n *   collection: \"documents\",\n *   label: \"DOCUMENT.Document\",\n *   types: [],\n *   embedded: {},\n *   hasSystemData: false,\n *   permissions: {\n *     create: \"ASSISTANT\",\n *     update: \"ASSISTANT\",\n *     delete: \"ASSISTANT\"\n *   },\n *   pack: null\n * }\n * ```\n */static get metadata():Metadata<any>;/**\n * The database backend used to execute operations and handle results\n */static get database():DatabaseBackend;/**\n * Return a reference to the implemented subclass of this base document type.\n */static get implementation():ConstructorOf<Document<any,any>>;/**\n * The named collection to which this Document belongs.\n */static get collectionName():string;/**\n * The canonical name of this Document type, for example \"Actor\".\n */static get documentName():string;/**\n * The named collection to which this Document belongs.\n */get collectionName():string;/**\n * The canonical name of this Document type, for example \"Actor\".\n */get documentName():string;/**\n * The canonical identifier for this Document\n */get id():string|null;/**\n * Test whether this Document is embedded within a parent Document\n */get isEmbedded():boolean;/**\n * The name of this Document, if it has one assigned\n */get name():string|null;/**\n * Test whether a given User has a sufficient role in order to create Documents of this type.\n * @param user - The User being tested\n * @returns Does the User have a sufficient role to create?\n */static canUserCreate(user:BaseUser):boolean;/**\n * Clone a document, creating a new document by combining current data with provided overrides.\n * The cloned document is ephemeral and not yet saved to the database.\n * @param data   - Additional data which overrides current document data at the time of creation\n *                 (default: `{}`)\n * @param save   - Save the clone to the World database?\n *                 (default: `false`)\n * @param keepId - Keep the original Document ID? Otherwise the ID will become undefined\n *                 (default: `false`)\n * @returns The cloned Document instance\n */\nclone(data?:DeepPartial<\nConstructorDataType<ConcreteDocumentData>|(ConstructorDataType<ConcreteDocumentData>&Record<string,unknown>)>,{save,keepId}?:{save?:boolean;keepId?:boolean}):TemporaryDocument<this>|Promise<TemporaryDocument<this>|undefined>;/**\n * Get the permission level that a specific User has over this Document, a value in CONST.ENTITY_PERMISSIONS.\n * @param user - The User being tested\n * @returns A numeric permission level from CONST.ENTITY_PERMISSIONS or null\n */\ngetUserLevel(user:BaseUser):foundry.CONST.EntityPermission|null;/**\n * Test whether a certain User has a requested permission level (or greater) over the Document\n * @param user       - The User being tested\n * @param permission - The permission level from ENTITY_PERMISSIONS to test\n * @param exact      - Require the exact permission level requested?\n *                     (default: `false`)\n * @returns Does the user have this permission level over the Document?\n */\ntestUserPermission(user:BaseUser,permission:keyof typeof foundry.CONST.ENTITY_PERMISSIONS|foundry.CONST.EntityPermission,{exact}?:{exact?:boolean}):boolean;/**\n * Test whether a given User has permission to perform some action on this Document\n * @param user   - The User attempting modification\n * @param action - The attempted action\n * @param data   - Data involved in the attempted action\n *                 (default: `{}`)\n * @returns  Does the User have permission?\n */\ncanUserModify(user:BaseUser,action:'create'|'update'|'delete',data?:object):boolean;/**\n * Create multiple Documents using provided input data.\n * Data is provided as an array of objects where each individual object becomes one new Document.\n *\n * @param data    - An array of data objects used to create multiple documents\n *                  (default: `[]`)\n * @param context - Additional context which customizes the creation workflow\n *                  (default: `{}`)\n * @returns An array of created Document instances\n *Additional context which customizes the creation workflow\n * @example <caption>Create a single Document</caption>\n * ```typescript\n * const data = [{name: \"New Actor\", type: \"character\", img: \"path/to/profile.jpg\"}];\n * const created = await Actor.createDocuments(data);\n * ```\n *\n * @example <caption>Create multiple Documents</caption>\n * ```typescript\n * const data = [{name: \"Tim\", type: \"npc\"], [{name: \"Tom\", type: \"npc\"}];\n * const created = await Actor.createDocuments(data);\n * ```\n *\n * @example <caption>Create multiple embedded Documents within a parent</caption>\n * ```typescript\n * const actor = game.actors.getName(\"Tim\");\n * const data = [{name: \"Sword\", type: \"weapon\"}, {name: \"Breastplate\", type: \"equipment\"}];\n * const created = await Item.createDocuments(data, {parent: actor});this\n * ```\n *\n * @example <caption>Create a Document within a Compendium pack</caption>\n * ```typescript\n * const data = [{name: \"Compendium Actor\", type: \"character\", img: \"path/to/profile.jpg\"}];\n * const created = await Actor.createDocuments(data, {pack: \"mymodule.mypack\"});\n * ```\n */static createDocuments<T extends DocumentConstructor>(this:T,data:Array<|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>)>,context:DocumentModificationContext&{temporary:false}):Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>[]>;static createDocuments<T extends DocumentConstructor>(this:T,data:Array<|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>)>,context:DocumentModificationContext&{temporary:boolean}):Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;static createDocuments<T extends DocumentConstructor>(this:T,data?:Array<|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>)>,context?:DocumentModificationContext):Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>[]>;/**\n * Update multiple Document instances using provided differential data.\n * Data is provided as an array of objects where each individual object updates one existing Document.\n *\n * @param updates - An array of differential data objects, each used to update a single Document\n *                  (default: `[]`)\n * @param context - Additional context which customizes the update workflow\n *                  (default: `{}`)\n * @returns An array of updated Document instances\n *\n * @example <caption>Update a single Document</caption>\n * ```typescript\n * const updates = [{_id: \"12ekjf43kj2312ds\", name: \"Timothy\"}];\n * const updated = await Actor.updateDocuments(updates);\n * ```\n *\n * @example <caption>Update multiple Documents</caption>\n * ```typescript\n * const updates = [{_id: \"12ekjf43kj2312ds\", name: \"Timothy\"}, {_id: \"kj549dk48k34jk34\", name: \"Thomas\"}]};\n * const updated = await Actor.updateDocuments(updates);\n * ```\n *\n * @example <caption>Update multiple embedded Documents within a parent</caption>\n * ```typescript\n * const actor = game.actors.getName(\"Timothy\");\n * const updates = [{_id: sword.id, name: \"Magic Sword\"}, {_id: shield.id, name: \"Magic Shield\"}];\n * const updated = await Item.updateDocuments(updates, {parent: actor});\n * ```\n *\n * @example <caption>Update Documents within a Compendium pack</caption>\n * ```typescript\n * const actor = await pack.getDocument(documentId);\n * const updated = await Actor.updateDocuments([{_id: actor.id, name: \"New Name\"}], {pack: \"mymodule.mypack\"});\n * ```\n */static updateDocuments<T extends DocumentConstructor>(this:T,updates?:Array<\nDeepPartial<|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>)>>,context?:DocumentModificationContext&foundry.utils.MergeObjectOptions):Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;/**\n * Delete one or multiple existing Documents using an array of provided ids.\n * Data is provided as an array of string ids for the documents to delete.\n *\n * @param ids - An array of string ids for the documents to be deleted\n *              (default: `[]`)\n * @param context - Additional context which customizes the update workflow\n *                  (default: `{}`)\n * @returns An array of deleted Document instances\n *\n * @example <caption>Delete a single Document</caption>\n * ```typescript\n * const tim = game.actors.getName(\"Tim\");\n * const deleted = await Actor.deleteDocuments([tim.id]);\n * ```\n *\n * @example <caption>Delete multiple Documents</caption>\n * ```typescript\n * const tim = game.actors.getName(\"Tim\");\n * const tom = game.actors.getName(\"Tom\");\n * const deleted = await Actor.deleteDocuments([tim.id, tom.id]);\n * ```\n *\n * @example <caption>Delete multiple embedded Documents within a parent</caption>\n * ```typescript\n * const tim = game.actors.getName(\"Tim\");\n * const sword = tim.items.getName(\"Sword\");\n * const shield = tim.items.getName(\"Shield\");\n * const deleted = await Item.deleteDocuments([sword.id, shield.id], parent: actor});\n * ```\n *\n * @example <caption>Delete Documents within a Compendium pack</caption>\n * ```typescript\n * const actor = await pack.getDocument(documentId);\n * const deleted = await Actor.deleteDocuments([actor.id], {pack: \"mymodule.mypack\"});\n * ```\n */static deleteDocuments<T extends DocumentConstructor>(this:T,ids?:string[],context?:DocumentModificationContext):Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;/**\n * Create a new Document using provided input data, saving it to the database.\n * @see {@link Document.createDocuments}\n * @param data    - Initial data used to create this Document\n * @param context - Additional context which customizes the creation workflow\n *                  (default: `{}`)\n * @returns The created Document instance\n *\n * @example <caption>Create a World-level Item</caption>\n * ```typescript\n * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n * const created = await Item.create(data);\n * ```\n *\n * @example <caption>Create an Actor-owned Item</caption>\n * ```typescript\n * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n * const actor = game.actors.getName(\"My Hero\");\n * const created = await Item.create(data, {parent: actor});\n * ```\n *\n * @example <caption>Create an Item in a Compendium pack</caption>\n * ```typescript\n * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n * const created = await Item.create(data, {pack: \"mymodule.mypack\"});\n * ```\n *\n * @remarks If no document has actually been created, the returned {@link Promise} resolves to `undefined`.\n */static create<T extends DocumentConstructor>(this:T,data:|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>),context:DocumentModificationContext&{temporary:false}):Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>|undefined>;static create<T extends DocumentConstructor>(this:T,data:|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>),context:DocumentModificationContext&{temporary:boolean}):Promise<InstanceType<ConfiguredDocumentClass<T>>|undefined>;static create<T extends DocumentConstructor>(this:T,data:|ConstructorDataType<InstanceType<T>['data']>|(ConstructorDataType<InstanceType<T>['data']>&Record<string,unknown>),context?:DocumentModificationContext):Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>|undefined>;/**\n * Update this Document using incremental data, saving it to the database.\n * @see {@link Document.updateDocuments}\n * @param data    - Differential update data which modifies the existing values of this document data\n *                  (default: `{}`)\n * @param context - Additional context which customizes the update workflow\n *                  (default: `{}`)\n * @returns The updated Document instance\n *\n * @remarks If no document has actually been updated, the returned {@link Promise} resolves to `undefined`.\n */\nupdate(data?:DeepPartial<\nConstructorDataType<ConcreteDocumentData>|(ConstructorDataType<ConcreteDocumentData>&Record<string,unknown>)>,context?:DocumentModificationContext&foundry.utils.MergeObjectOptions):Promise<this|undefined>;/**\n * Delete this Document, removing it from the database.\n * @see {@link Document.deleteDocuments}\n * @param context - Additional context which customizes the deletion workflow\n *                  (default: `{}`)\n * @returns The deleted Document instance\n *\n * @remarks If no document has actually been deleted, the returned {@link Promise} resolves to `undefined`.\n */delete(context?:DocumentModificationContext):Promise<this|undefined>;/**\n * Obtain a reference to the Array of source data within the data object for a certain embedded Document name\n * @param embeddedName - The name of the embedded Document type\n * @returns The Collection instance of embedded Documents of the requested type\n */\ngetEmbeddedCollection(embeddedName:string):EmbeddedCollection<DocumentConstructor,AnyDocumentData>;/**\n * Get an embedded document by it's id from a named collection in the parent document.\n * @param embeddedName - The name of the embedded Document type\n * @param id           - The id of the child document to retrieve\n * @param options      - Additional options which modify how embedded documents are retrieved\n * @param strict       - Throw an Error if the requested id does not exist. See Collection#get\n *                       (default: `false`)\n * @returns The retrieved embedded Document instance, or undefined\n */\ngetEmbeddedDocument(embeddedName:string,id:string,{strict}?:{strict?:boolean}):Document<any,this>|undefined;/**\n * Create multiple embedded Document instances within this parent Document using provided input data.\n * @see {@link Document.createDocuments}\n * @param embeddedName - The name of the embedded Document type\n * @param data         - An array of data objects used to create multiple documents\n *                       (default: `[]`)\n * @param context      - Additional context which customizes the creation workflow\n *                       (default: `{}`)\n * @returns An array of created Document instances\n */\ncreateEmbeddedDocuments(embeddedName:string,data:Array<Record<string,unknown>>,context:DocumentModificationContext&{temporary:false}):Promise<Array<StoredDocument<Document<any,this>>>>;createEmbeddedDocuments(embeddedName:string,data:Array<Record<string,unknown>>,context:DocumentModificationContext&{temporary:boolean}):Promise<Array<Document<any,this>>>;createEmbeddedDocuments(embeddedName:string,data:Array<Record<string,unknown>>,context?:DocumentModificationContext):Promise<Array<StoredDocument<Document<any,this>>>>;/**\n * Update multiple embedded Document instances within a parent Document using provided differential data.\n * @see {@link Document.updateDocuments}\n * @param embeddedName - The name of the embedded Document type\n * @param updates      - An array of differential data objects, each used to update a single Document\n *                       (default: `[]`)\n * @param context      - Additional context which customizes the creation workflow\n *                       (default: `{}`)\n * @returns An array of updated Document instances\n */\nupdateEmbeddedDocuments(embeddedName:string,updates?:Array<Record<string,unknown>>,context?:DocumentModificationContext):Promise<Array<Document<any,this>>>;/**\n * Delete multiple embedded Document instances within a parent Document using provided string ids.\n * @see {@link Document.deleteDocuments}\n * @param embeddedName - The name of the embedded Document type\n * @param ids          - An array of string ids for each Document to be deleted\n * @param context      - Additional context which customizes the deletion workflow\n *                       (default: `{}`)\n * @returns An array of deleted Document instances\n */\ndeleteEmbeddedDocuments(embeddedName:string,ids:Array<string>,context?:DocumentModificationContext):Promise<Array<Document<any,this>>>;/**\n * Get the value of a \"flag\" for this document\n * See the setFlag method for more details on flags\n *\n * @param scope - The flag scope which namespaces the key\n * @param key   - The flag key\n * @returns The flag value\n */\ngetFlag<\nS extends keyof ConcreteDocumentData['_source']['flags'],K extends keyof ConcreteDocumentData['_source']['flags'][S]>(scope:S,key:K):ConcreteDocumentData['_source']['flags'][S][K];getFlag<\nS extends keyof ConcreteDocumentData['_source']['flags'],K extends keyof Required<ConcreteDocumentData['_source']['flags']>[S]>(scope:S,key:K):Required<ConcreteDocumentData['_source']['flags']>[S][K]|undefined;getFlag<S extends keyof ConcreteDocumentData['_source']['flags']>(scope:S,key:string):unknown extends ConcreteDocumentData['_source']['flags'][S]?unknown:never;getFlag(scope:string,key:string):unknown;/**\n * Assign a \"flag\" to this document.\n * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either\n * the core software, game systems, or user-created modules.\n *\n * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.\n *\n * Flags set by the core software use the \"core\" scope.\n * Flags set by game systems or modules should use the canonical name attribute for the module\n * Flags set by an individual world should \"world\" as the scope.\n *\n * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.\n *\n * @param scope - The flag scope which namespaces the key\n * @param key   - The flag key\n * @param value - The flag value\n * @returns A Promise resolving to the updated document\n */\nsetFlag<\nS extends keyof ConcreteDocumentData['_source']['flags'],K extends keyof Required<ConcreteDocumentData['_source']['flags']>[S],V extends Required<ConcreteDocumentData['_source']['flags']>[S][K]>(scope:S,key:K,value:V):Promise<this>;setFlag<S extends keyof ConcreteDocumentData['_source']['flags'],K extends string>(scope:S,key:K,v:unknown extends ConcreteDocumentData['_source']['flags'][S]?unknown:never):Promise<this>;/**\n * Remove a flag assigned to the document\n * @param scope - The flag scope which namespaces the key\n * @param key   - The flag key\n * @returns The updated document instance\n */\nunsetFlag(scope:string,key:string):Promise<this>;/**\n * Perform preliminary operations before a Document of this type is created.\n * Pre-creation operations only occur for the client which requested the operation.\n * @param data    - The initial data used to create the document\n * @param options - Additional options which modify the creation request\n * @param user    - The User requesting the document creation\n */protected _preCreate(data:ConstructorDataType<ConcreteDocumentData>,options:DocumentModificationOptions,user:BaseUser):Promise<void>;/**\n * Perform preliminary operations before a Document of this type is updated.\n * Pre-update operations only occur for the client which requested the operation.\n * @param changed - The differential data that is changed relative to the documents prior values\n * @param options - Additional options which modify the update request\n * @param user    - The User requesting the document update\n */protected _preUpdate(changed:DeepPartial<ConstructorDataType<ConcreteDocumentData>>,options:DocumentModificationOptions,user:BaseUser):Promise<void>;/**\n * Perform preliminary operations before a Document of this type is deleted.\n * Pre-delete operations only occur for the client which requested the operation.\n * @param options - Additional options which modify the deletion request\n * @param user    - The User requesting the document deletion\n */protected _preDelete(options:DocumentModificationOptions,user:BaseUser):Promise<void>;/**\n * Perform follow-up operations after a Document of this type is created.\n * Post-creation operations occur for all clients after the creation is broadcast.\n * @param data   - The data from which the document was created\n * @param options- Additional options which modify the creation request\n * @param user   - The id of the User requesting the document update\n */protected _onCreate(data:ConcreteDocumentData['_source'],options:DocumentModificationOptions,userId:string):void;/**\n * Perform follow-up operations after a Document of this type is updated.\n * Post-update operations occur for all clients after the update is broadcast.\n * @param changed - The differential data that was changed relative to the documents prior values\n * @param options - Additional options which modify the update request\n * @param user    - The id of the User requesting the document update\n */protected _onUpdate(changed:DeepPartial<ConcreteDocumentData['_source']>,options:DocumentModificationOptions,userId:string):void;/**\n * Perform follow-up operations after a Document of this type is deleted.\n * Post-deletion operations occur for all clients after the deletion is broadcast.\n * @param options- Additional options which modify the deletion request\n * @param user   - The id of the User requesting the document update\n */protected _onDelete(options:DocumentModificationOptions,userId:string):void;/**\n * Perform follow-up operations when a set of Documents of this type are created.\n * This is where side effects of creation should be implemented.\n * Post-creation side effects are performed only for the client which requested the operation.\n * @param documents- The Document instances which were created\n * @param context  - The context for the modification operation\n *\n * @remarks The base implementation returns `void` but it is typed as\n * `unknown` to allow deriving classes to return whatever they want. The\n * return type is not meant to be used.\n */protected static _onCreateDocuments<T extends DocumentConstructor>(this:T,documents:Array<InstanceType<ConfiguredDocumentClass<T>>>,context:DocumentModificationContext):Promise<unknown>;/**\n * Perform follow-up operations when a set of Documents of this type are updated.\n * This is where side effects of updates should be implemented.\n * Post-update side effects are performed only for the client which requested the operation.\n * @param documents - The Document instances which were updated\n * @param context   - The context for the modification operation\n *\n * @remarks The base implementation returns `void` but it is typed as\n * `unknown` to allow deriving classes to return whatever they want. The\n * return type is not meant to be used.\n */protected static _onUpdateDocuments<T extends DocumentConstructor>(this:T,documents:Array<InstanceType<ConfiguredDocumentClass<T>>>,context:DocumentModificationContext):Promise<unknown>;/**\n * Perform follow-up operations when a set of Documents of this type are deleted.\n * This is where side effects of deletion should be implemented.\n * Post-deletion side effects are performed only for the client which requested the operation.\n * @param documents - The Document instances which were deleted\n * @param context   - The context for the modification operation\n *\n * @remarks The base implementation returns `void` but it is typed as\n * `unknown` to allow deriving classes to return whatever they want. The\n * return type is not meant to be used.\n */protected static _onDeleteDocuments<T extends DocumentConstructor>(this:T,documents:Array<InstanceType<ConfiguredDocumentClass<T>>>,context:DocumentModificationContext):Promise<unknown>;/**\n * Transform the Document instance into a plain object.\n * The created object is an independent copy of the original data.\n * See DocumentData#toObject\n * @param source - Draw values from the underlying data source rather than transformed values\n * @returns The extracted primitive object\n */\ntoObject(source?:true):ReturnType<this['toJSON']>;toObject(source:false):this['id']extends string?ToObjectFalseType<ConcreteDocumentData>&{_id:string}:ToObjectFalseType<ConcreteDocumentData>;/**\n * Convert the Document instance to a primitive object which can be serialized.\n * See DocumentData#toJSON\n * @returns The document data expressed as a plain object\n */\ntoJSON():this['id']extends string?ReturnType<ConcreteDocumentData['toJSON']>&{_id:string}:ReturnType<ConcreteDocumentData['toJSON']>;}export interface DocumentModificationOptions{/**\n * Block the dispatch of preCreate hooks for this operation\n * @defaultValue `false`\n */\nnoHook?:boolean;/**\n * Return an index of the Document collection, used only during a get operation.\n * @defaultValue `false`\n */\nindex?:boolean;/**\n * When performing a creation operation, keep the provided _id instead of clearing it.\n * @defaultValue `false`\n */\nkeepId?:boolean;/**\n * Create a temporary document which is not saved to the database. Only used during creation.\n * @defaultValue `false`\n */\ntemporary?:boolean;/**\n * Automatically re-render existing applications associated with the document.\n * @defaultValue `true`\n */\nrender?:boolean;/**\n * Automatically create and render the Document sheet when the Document is first created.\n * @defaultValue `false`\n */\nrenderSheet?:boolean;/**\n * Difference each update object against current Document data to reduce the size of the transferred data. Only used during update.\n * @defaultValue `true`\n */\ndiff?:boolean;/**\n * Merge objects recursively. If false, inner objects will be replaced explicitly. Use with caution!\n * @defaultValue `true`\n */\nrecursive?:boolean;/**\n * Is the operation undoing a previous operation, only used by embedded Documents within a Scene\n */\nisUndo?:boolean;/**\n * Whether to delete all documents of a given type, regardless of the array of ids provided. Only used during a delete operation.\n */\ndeleteAll?:boolean;}declare global{interface DocumentModificationContext extends DocumentModificationOptions{/**\n * A parent Document within which these Documents should be embedded\n */\nparent?:Document<any,any>;/**\n * A Compendium pack identifier within which the Documents should be modified\n */\npack?:string;}}export interface Context<Parent extends Document<any,any>|null>{/**\n * A parent document within which this Document is embedded\n */\nparent?:Parent;/**\n * A named compendium pack within which this Document exists\n */\npack?:string;}export interface Metadata<ConcreteDocument extends Document<any,any>>{name:DocumentType;collection:string;label:string;types:string[]|Record<string,unknown>;embedded:Record<string,ConstructorOf<Document<any,any>>>;hasSystemData:boolean;permissions:{create:string|((user:BaseUser,doc:ConcreteDocument,data?:object)=>boolean);update:string|((user:BaseUser,doc:ConcreteDocument,data?:object)=>boolean);delete:string|((user:BaseUser,doc:ConcreteDocument,data?:object)=>boolean);};pack:any;}export interface DocumentMetadata{name:'Document';collection:'documents';label:'DOCUMENT.Document';types:[];embedded:{};hasSystemData:false;permissions:{create:'ASSISTANT';update:'ASSISTANT';delete:'ASSISTANT';};pack:null;}export default Document;"
    ]
  