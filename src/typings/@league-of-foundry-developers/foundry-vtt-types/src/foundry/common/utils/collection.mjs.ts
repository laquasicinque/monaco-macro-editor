
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\common\\utils\\collection.mjs.d.ts",
      "interface MapReplacementMembers<K,V>{set(key:K,value:V):this;}type PatchedMap<K,V>=Omit<Map<K,V>,'forEach'|typeof Symbol.iterator|'get'|'set'>&\nMapReplacementMembers<K,V>;interface PatchedMapConstructor{new():PatchedMap<any,any>;new<K,V>(entries?:readonly(readonly[K,V])[]|null):PatchedMap<K,V>;new<K,V>(iterable:Iterable<readonly[K,V]>):PatchedMap<K,V>;readonly[Symbol.species]:PatchedMapConstructor;readonly prototype:PatchedMap<any,any>;}declare const Map:PatchedMapConstructor;/**\n * A reusable storage concept which blends the functionality of an Array with the efficient key-based lookup of a Map.\n * This concept is reused throughout Foundry VTT where a collection of uniquely identified elements is required.\n * @typeParam T - The type of the objects contained in the Collection\n */declare class Collection<T>extends Map<string,T>{constructor(entries?:readonly(readonly[string,T])[]|null);/**\n * When iterating over a Collection, we should iterate over its values instead of over its entries\n */[Symbol.iterator]():IterableIterator<T>;/**\n * Return an Array of all the entry values in the Collection\n */get contents():T[];/**\n * Find an entry in the Map using an functional condition.\n * @see {@link Array#find}\n *\n * @param condition - The functional condition to test\n * @returns The value, if found, otherwise undefined\n *\n * @example\n * ```typescript\n * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n * let a = c.find(entry => entry === \"A\");\n * ```\n */\nfind<S extends T>(condition:(e:T)=>e is S):S|undefined;find(condition:(e:T)=>boolean):T|undefined;/**\n * Filter the Collection, returning an Array of entries which match a functional condition.\n * @see {@link Array#filter}\n *\n * @param condition - The functional condition to test\n * @returns An Array of matched values\n *\n * @example\n * ```typescript\n * let c = new Collection([[\"a\", \"AA\"], [\"b\", \"AB\"], [\"c\", \"CC\"]]);\n * let hasA = c.filters(entry => entry.slice(0) === \"A\");\n * ```\n */\nfilter<S extends T>(condition:(e:T)=>e is S):S[];filter(condition:(e:T)=>boolean):T[];/**\n * Apply a function to each element of the collection\n * @see Array#forEach\n * @param fn - The function to apply\n *\n * @example\n * ```typescript\n * let c = new Collection([[\"a\", {active: false}], [\"b\", {active: false}], [\"c\", {active: false}]]);\n * c.forEach(e => e.active = true);\n * ```\n */\nforEach(fn:(e:T)=>void):void;/**\n * Get an element from the Collection by its key.\n * @param key     - The key of the entry to retrieve\n * @param strict  - Throw an Error if the requested id does not exist, otherwise\n *                  (default: `false`)\n * @returns The retrieved entry value, if the key exists, otherwise undefined\n * @example\n * ```typescript\n * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n * c.get(\"a\"); // \"A\"\n * c.get(\"d\"); // null\n * c.get(\"d\", {strict: true}); // throws Error\n * ```\n */get(key:string,{strict}:{strict:true}):T;get(key:string,{strict}?:{strict?:false}):T|undefined;/**\n * Get an entry from the Collection by name.\n * Use of this method assumes that the objects stored in the collection have a \"name\" attribute.\n * @param name    - The name of the entry to retrieve\n * @param strict  - Throw an Error if the requested id does not exist,\n *                  otherwise return null.\n *                  (default: `false`)\n * @returns The retrieved Entity, if one was found, otherwise undefined\n */\ngetName(name:string,{strict}:{strict:true}):T;getName(name:string,{strict}?:{strict?:false}):T|undefined;/**\n * Transform each element of the Collection into a new form, returning an Array of transformed values\n * @param transformer - The transformation function to apply to each entry value\n * @typeParam M       - The type of the mapped values\n * @returns An Array of transformed values\n */\nmap<M>(transformer:(entity:T)=>M):M[];/**\n * Reduce the Collection by applying an evaluator function and accumulating entries\n * @see {@link Array#reduce}\n * @param evaluator - A function which mutates the accumulator each iteration\n * @param initial   - An initial value which accumulates with each iteration\n * @typeParam A     - The type of the accumulator and the return value\n * @returns The accumulated result\n *\n * @example\n * ```typescript\n * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n * let letters = c.reduce((s, l) => {\n *   return s + l;\n * }, \"\"); // \"ABC\"\n * ```\n */\nreduce<A>(evaluator:(accumulator:A,entity:T)=>A,initial:A):A;/**\n * Test whether a condition is met by some entry in the Collection\n * @see Array#some\n * @param condition - A test condition to apply to each entry\n * @returns Was the test condition passed by at least one entry?\n */\nsome(condition:(e:T)=>boolean):boolean;/**\n * Convert the Collection to a primitive array of its contents.\n * @returns An array of contained values\n */\ntoJSON():Array<T extends{toJSON:(...args:any[])=>infer U}?U:T>;}export default Collection;"
    ]
  