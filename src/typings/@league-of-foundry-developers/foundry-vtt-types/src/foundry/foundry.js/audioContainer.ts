
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\audioContainer.d.ts",
      "/**\n * An AudioSourceNode container which handles the strategy of node type to use for playback.\n * Used by the Sound interface which controls playback.\n * This class is for internal use only and should not be used by external callers.\n * @internal\n */declare class AudioContainer{constructor(src:string);/**\n * The audio source path\n */\nsrc:string;/**\n * The Audio Node used to control this sound\n * @defaultValue `undefined`\n */\nsourceNode:AudioBufferSourceNode|MediaElementAudioSourceNode|undefined;/**\n * The GainNode used to control volume\n * @defaultValue `undefined`\n */\ngainNode:GainNode|undefined;/**\n * Is this container using an AudioBuffer?\n * @defaultValue `false`\n */\nisBuffer:boolean;/**\n * Has the source for this audio container been loaded to a point that playback can begin?\n * @defaultValue `false`\n */\nloaded:boolean;/**\n * Did the audio source fail to load (a 404 or some other reason).\n * @defaultValue `false`\n */\nfailed:boolean;/**\n * Is the audio source currently playing?\n * @defaultValue `false`\n */\nplaying:boolean;/**\n * Should the audio source loop?\n * @defaultValue `false`\n * @internal\n */protected _loop:boolean;get loop():boolean;set loop(looping:boolean);/**\n * The maximum duration, in seconds, for which an AudioBuffer will be used.\n * Otherwise a streaming media element will be used.\n * @defaultValue `10 * 60`\n */static MAX_BUFFER_DURATION:number;/**\n * A reference to the AudioBuffer if the sourceNode is a AudioBufferSourceNode.\n */get buffer():AudioBuffer|null|undefined;/**\n * The game audio context used throughout the application.\n */get context():AudioContext;/**\n * The total duration of the audio source in seconds\n */get duration():number|undefined;/**\n * A reference to the HTMLMediaElement, if the sourceNode is a MediaElementAudioSourceNode.\n */get element():HTMLMediaElement|undefined;/**\n * Load the source node required for playback of this audio source\n */\nload():Promise<void>;/**\n * Create the initial audio node used for playback.\n * Determine the node type to use based on cached state and sound duration.\n * @internal\n */protected _createNode():Promise<AudioBufferSourceNode|MediaElementAudioSourceNode|undefined>;/**\n * Create an Audio source node using a buffered array.\n * @internal\n */protected _createAudioBuffer():Promise<AudioBuffer>;/**\n * Create a AudioBufferSourceNode using a provided AudioBuffer\n * @internal\n */protected _createAudioBufferSourceNode(buffer:AudioBuffer):AudioBufferSourceNode;/**\n * Create an HTML5 Audio element which has loaded the metadata for the provided source.\n * @internal\n */protected _createAudioElement():Promise<HTMLAudioElement>;/**\n * Create a MediaElementAudioSourceNode using a provided HTMLAudioElement\n * @internal\n */protected _createMediaElementAudioSourceNode(element:HTMLAudioElement):MediaElementAudioSourceNode;/**\n * Begin playback for the source node.\n * @param offset  - The desired start time\n * @param onended - A callback function for when playback concludes naturally\n */\nplay(offset:number,onended:()=>void):void;/**\n * Pre-playback actions that are needed depending on the node type\n * @internal\n */protected _configureNode():void;/**\n * Terminate playback for the source node.\n */\nstop():void;/**\n * Perform cleanup actions when the sound has finished playing. For\n * MediaElementAudioSourceNodes, this also means optionally restarting if\n * the sound is supposed to loop.\n * @param onended - A callback provided by the owner of the container that gets fired when the sound ends.\n * @internal\n */protected _onEnd(onended:()=>void):void;/**\n * Unload the MediaElementAudioSourceNode to terminate any ongoing\n * connections.\n * @internal\n */protected _unloadMediaNode():void;}"
    ]
  