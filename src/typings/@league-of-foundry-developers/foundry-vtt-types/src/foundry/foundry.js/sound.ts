
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\sound.d.ts",
      "/**\n * The Sound class is used to control the playback of audio sources using the Web Audio API.\n */declare class Sound{constructor(src:string);/**\n * The numeric identifier for accessing this node\n */\nid:number;/**\n * The audio source path\n */\nsrc:string;/**\n * The AudioContainer which controls playback\n */\ncontainer:AudioContainer;/**\n * The time in seconds at which playback was started\n * @defaultValue `undefined`\n */\nstartTime:number|undefined;/**\n * The time in seconds at which playback was paused\n * @defaultValue `undefined`\n */\npausedTime:number|undefined;/**\n * Registered event callbacks\n * @defaultValue `{stop: {}, start: {}, end: {}, pause: {}, load: {}}`\n */\nevents:Sound.EventCallbacks;/**\n * The registered event handler id for this Sound.\n * Incremented each time a callback is registered.\n * @defaultValue `1`\n * @internal\n */protected _eventHandlerId:number;/**\n * If this Sound source is currently in the process of loading, this attribute contains a Promise that will resolve\n * when the loading process completes.\n * @defaultValue `undefined`\n */\nloading:Promise<void>|undefined;/**\n * A collection of scheduled events recorded as window timeout IDs\n * @internal\n */protected _scheduledEvents:Set<number>;/**\n * A global audio node ID used to quickly reference a specific audio node\n * @defaultValue `0`\n * @internal\n */protected static _nodeId:number;/**\n * A convenience reference to the sound context used by the application\n */get context():AudioContext;/**\n * A reference to the audio source node being used by the AudioContainer\n */get node():AudioBufferSourceNode|MediaElementAudioSourceNode|undefined;/**\n * A reference to the GainNode parameter which controls volume\n */get gain():AudioParam|undefined;/**\n * The current playback time of the sound\n */get currentTime():number|undefined;/**\n * The total sound duration, in seconds\n */get duration():number|undefined;/**\n * Is the contained audio node loaded and ready for playback?\n */get loaded():boolean;/**\n * Did the contained audio node fail to load?\n */get failed():boolean;/**\n * Is the audio source currently playing?\n */get playing():boolean;/**\n * Is the Sound current looping?\n */get loop():boolean;set loop(looping:boolean);/**\n * The volume at which the Sound is playing\n */get volume():number|undefined;set volume(value:number|undefined);/**\n * Fade the volume for this sound between its current level and a desired target volume\n * @param volume  - The desired target volume level between 0 and 1\n * @param options - Additional options that configure the fade operation\n *                  (default: `{}`)\n * @returns A Promise that resolves after the requested fade duration\n */\nfade(volume:number,options?:Sound.FadeOptions):Promise<void>;/**\n * Load the audio source, creating an AudioBuffer.\n * Audio loading is idempotent, it can be requested multiple times but only the first load request will be honored.\n * @param options - Additional options which affect resource loading\n *                  (default: `{}`)\n * @returns The Sound once its source audio buffer is loaded\n */\nload(options?:Sound.LoadOptions):Promise<Sound>;/**\n * Begin playback for the sound node\n * @param options - Options which configure playback\n *                  (default: `{}`)\n */\nplay(options?:Sound.PlayOptions):void;/**\n * Pause playback, remembering the playback position in order to resume later.\n */\npause():void;/**\n * Stop playback, fully resetting the Sound to a non-playing state.\n */\nstop():void;/**\n * Schedule a function to occur at the next occurrence of a specific playbackTime for this Sound.\n * @param fn           - A function that will be called with this Sound as its single argument\n * @param playbackTime - The desired playback time at which the function should be called\n * @returns A Promise which resolves once the scheduled function has been called\n *\n * @example\n * ```typescript\n * sound.schedule(() => console.log(\"Do something exactly 30 seconds into the track\"), 30);\n * sound.schedule(() => console.log(\"Do something next time the track loops back to the beginning\"), 0);\n * sound.schedule(() => console.log(\"Do something 5 seconds before the end of the track\"), sound.duration - 5);\n * ```\n */\nschedule(fn:Sound.Callback,playbackTime:number):Promise<void>;/**\n * Trigger registered callback functions for a specific event name.\n * @param eventName - The event name being emitted\n */\nemit(eventName:Sound.EventName):void;/**\n * Deactivate an event handler which was previously registered for a specific event\n * @param eventName - The event name being deactivated\n * @param fn        - The callback ID or callback function being un-registered\n */\noff(eventName:Sound.EventName,fn:number|Sound.Callback):void;/**\n * Register an event handler to take actions for a certain Sound event.\n * @param eventName- The event name being deactivated\n * @param fn       - The callback function to trigger when the event occurs\n * @param options  - Additional options that affect callback registration\n *                   (default: `{}`)\n */\non(eventName:Sound.EventName,fn:Sound.Callback,options?:Sound.OnOptions):number;/**\n * Register a new callback function for a certain event. For internal use only.\n * @internal\n */protected _registerForEvent(eventName:Sound.EventName,callback:Sound.Callback):number;/**\n * Cancel all pending scheduled events.\n * @internal\n */protected _clearEvents():void;/**\n * Called when playback concludes naturally\n */protected _onEnd():void;/**\n * Called when the audio buffer is first loaded\n */protected _onLoad():void;/**\n * Called when playback is paused\n */protected _onPause():void;/**\n * Called when the sound begins playing\n */protected _onStart():void;/**\n * Called when playback is stopped (prior to naturally reaching the end)\n */protected _onStop():void;}declare namespace Sound{type Callback=(sound:Sound)=>void;type EventName='end'|'pause'|'start'|'stop'|'load';type EventCallbacks=Record<EventName,Partial<Record<number,Callback>>>;type FadeType='linear'|'exponential';interface FadeOptions{/**\n * The duration of the fade effect in milliseconds\n * @defaultValue `1000`\n */\nduration?:number;/**\n * A volume level to start from, the current volume by default\n */from?:number;/**\n * The type of fade easing, 'linear' or 'exponential'\n * @defaultValue `'linear'`\n */type?:FadeType;}interface LoadOptions{/**\n * Automatically begin playback of the audio source once loaded\n * @defaultValue `false`\n */\nautoplay?:boolean;/**\n * Additional options passed to the play method when loading is complete\n * @defaultValue `{}`\n */\nautoplayOptions?:PlayOptions;}interface PlayOptions{/**\n * Whether to loop the audio automatically\n * @defaultValue `false`\n */\nloop?:boolean;/**\n * A specific offset in seconds at which to begin playback\n */\noffset?:number;/**\n * The desired volume at which to begin playback\n */\nvolume?:number;/**\n * Fade volume changes over a desired duration in milliseconds\n * @defaultValue `0`\n */\nfade?:number;}interface OnOptions{/**\n * Trigger the callback once only and automatically un-register it\n * @defaultValue `false`\n */\nonce?:boolean;}}"
    ]
  