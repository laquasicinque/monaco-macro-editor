
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\clientDocuments\\canvasDocuments\\tokenDocument.d.ts",
      "import{ConfiguredDocumentClass}from'../../../../types/helperTypes';import{DocumentModificationOptions}from'../../../common/abstract/document.mjs';import*as data from'../../../common/data/data.mjs';declare global{/**\n * The client-side Token document which extends the common BaseToken model.\n * Each Token document contains TokenData which defines its data schema.\n *\n * @see {@link data.TokenData}                The Token data schema\n * @see {@link documents.Scene}               The Scene document type which contains Token embedded documents\n * @see {@link applications.TokenConfig}      The Token configuration application\n */class TokenDocument extends CanvasDocumentMixin(foundry.documents.BaseToken){/**\n * @param data    - Initial data provided to construct the Token document\n *                  (default: `{}`)\n * @param context - The parent Scene document to which this Token belongs\n */constructor(data?:ConstructorParameters<ConstructorOf<foundry.documents.BaseToken>>[0],context?:ConstructorParameters<ConstructorOf<foundry.documents.BaseToken>>[1]);/**\n * A cached reference to the Actor document that this Token modifies.\n * This may be a \"synthetic\" unlinked Token Actor which does not exist in the World.\n */protected _actor:InstanceType<ConfiguredDocumentClass<typeof Actor>>|null;/**\n * A lazily evaluated reference to the Actor this Token modifies.\n * If actorLink is true, then the entity is the primary Actor document.\n * Otherwise the Actor entity is a synthetic (ephemeral) document constructed using the Token's actorData.\n */get actor():InstanceType<ConfiguredDocumentClass<typeof Actor>>|null;/**\n * An indicator for whether or not the current User has full control over this Token document.\n */get isOwner():boolean;/**\n * A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy\n */get isLinked():boolean;/**\n * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.\n */get combatant():InstanceType<ConfiguredDocumentClass<typeof Combatant>>|null;/**\n * An indicator for whether or not this Token is currently involved in the active combat encounter.\n */get inCombat():boolean;/**\n * @param data    - (default: `{}`, unused)\n * @param options - (default: `{}`, unused)\n * @override\n */\nclone(data?:Parameters<foundry.documents.BaseToken['clone']>[0],options?:Parameters<foundry.documents.BaseToken['clone']>[1]):TemporaryDocument<this>;/**\n * Create a synthetic Actor using a provided Token instance\n * If the Token data is linked, return the true Actor entity\n * If the Token data is not linked, create a synthetic Actor using the Token's actorData override\n */\ngetActor():InstanceType<ConfiguredDocumentClass<typeof Actor>>|null;/**\n * A helper method to retrieve the underlying data behind one of the Token's attribute bars\n * @param barName     - The named bar to retrieve the attribute for\n * @param alternative - An alternative attribute path to get instead of the default one\n * @returns The attribute displayed on the Token bar, if any\n */\ngetBarAttribute(barName:string,{alternative}?:{alternative?:string}):SingleAttributeBar|ObjectAttributeBar|null;/**\n * Redirect updates to a synthetic Token Actor to instead update the tokenData override object.\n * Once an attribute in the Token has been overridden, it must always remain overridden.\n *\n * @param update  - The provided differential update data which should update the Token Actor\n * @param options - Provided options which modify the update request\n * @returns The updated un-linked Actor instance\n */\nmodifyActorDocument(update:Parameters<InstanceType<ConfiguredDocumentClass<typeof Actor>>['update']>[0],options:Parameters<this['update']>[1]):Promise<[this['actor']]>;/** @override */\ngetEmbeddedCollection(embeddedName:'Item'):data.ActorData['items'];getEmbeddedCollection(embeddedName:'ActiveEffect'):data.ActorData['effects'];/**\n * Redirect creation of Documents within a synthetic Token Actor to instead update the tokenData override object.\n * @param embeddedName - The named embedded Document type being modified\n * @param data         - The provided initial data with which to create the embedded Documents\n * @param options      - Provided options which modify the creation request\n * @returns The created Embedded Document instances\n */\ncreateActorEmbeddedDocuments(embeddedName:'Item',data:Array<ConstructorParameters<ConfiguredDocumentClass<typeof Item>>[0]|Record<string,unknown>>,options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;createActorEmbeddedDocuments(embeddedName:'ActiveEffect',data:Array<ConstructorParameters<ConfiguredDocumentClass<typeof ActiveEffect>>[0]|Record<string,unknown>>,options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;/**\n * Redirect updating of Documents within a synthetic Token Actor to instead update the tokenData override object.\n * @param embeddedName - The named embedded Document type being modified\n * @param updates      - The provided differential data with which to update the embedded Documents\n * @param options      - Provided options which modify the update request\n * @returns The updated Embedded Document instances\n */\nupdateActorEmbeddedDocuments(embeddedName:'Item',updates:Array<ConstructorParameters<ConfiguredDocumentClass<typeof Item>>[0]|Record<string,unknown>>,options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;updateActorEmbeddedDocuments(embeddedName:'ActiveEffect',updates:Array<ConstructorParameters<ConfiguredDocumentClass<typeof ActiveEffect>>[0]|Record<string,unknown>>,options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;/**\n * Redirect deletion of Documents within a synthetic Token Actor to instead update the tokenData override object.\n * @param embeddedName - The named embedded Document type being modified\n * @param ids          - The provided differential data with which to update the embedded Documents\n * @param options      - Provided options which modify the update request\n * @returns The updated Embedded Document instances\n */\ndeleteActorEmbeddedDocuments(embeddedName:'Item',ids:string[],options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;deleteActorEmbeddedDocuments(embeddedName:'ActiveEffect',ids:string[],options:Parameters<this['update']>[1]):Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;/** @override */protected _preUpdate(data:Parameters<foundry.documents.BaseToken['_preUpdate']>[0],options:DocumentModificationOptions,user:InstanceType<ConfiguredDocumentClass<typeof User>>):Promise<void>;/**\n * When the Actor data overrides change for an un-linked Token Actor, simulate the pre-update process.\n */protected _preUpdateTokenActor(data:Parameters<foundry.documents.BaseActor['_preUpdate']>[0],options:DocumentModificationOptions,user:InstanceType<ConfiguredDocumentClass<typeof User>>):Promise<void>;/** @override */protected _onUpdate(data:Parameters<foundry.documents.BaseToken['_onUpdate']>[0],options:DocumentModificationOptions,userId:string):void;/**\n * When the base Actor for a TokenDocument changes, we may need to update its Actor instance\n * @param update - (default: `{}`)\n */protected _onUpdateBaseActor(update?:Parameters<foundry.documents.BaseActor['_onUpdate']>[0]):void;/**\n * When the Actor data overrides change for an un-linked Token Actor, simulate the post-update process.\n */protected _onUpdateTokenActor(data:Parameters<foundry.documents.BaseActor['_onUpdate']>[0],options:DocumentModificationOptions,userId:string):void;/**\n * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker\n * @param _path - (default: `[]`)\n */static getTrackedAttributes(data?:InstanceType<ConfiguredDocumentClass<typeof Actor>>['data']['data'],_path?:string[]):TrackedAttributes;/**\n * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar\n */static getTrackedAttributeChoices(attributes?:TrackedAttributes):Partial<Record<string,string[]>>;}}interface SingleAttributeBar{type:'value';attribute:string;value:number;editable:boolean;}interface ObjectAttributeBar{type:'bar';attribute:string;value:number;max:number;editable:boolean;}interface TrackedAttributes{bar:string[][];value:string[][];}export{};"
    ]
  