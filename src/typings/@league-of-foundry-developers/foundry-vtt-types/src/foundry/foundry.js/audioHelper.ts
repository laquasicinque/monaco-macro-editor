
    export default [
      "@league-of-foundry-developers\\foundry-vtt-types\\src\\foundry\\foundry.js\\audioHelper.d.ts",
      "/**\n * A helper class to provide common functionality for working with the Web Audio API.\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\n * A singleton instance of this class is available as game#audio.\n * @see Game#audio\n */declare class AudioHelper{constructor();/**\n * The primary Audio Context used to play client-facing sounds.\n * The context is undefined until the user's first gesture is observed.\n * @defaultValue `undefined`\n */\ncontext:AudioContext|undefined;/**\n * The set of AudioBuffer objects which are cached for different audio paths\n */\nbuffers:Map<string,AudioBuffer>;/**\n * The set of singleton Sound instances which are cached for different audio paths\n */\nsounds:Map<string,Sound>;/**\n * Get a map of the Sound objects which are currently playing.\n * @remarks It's not actually an `Array` but a `Map`.\n */\nplaying:Map<number,Sound>;/**\n * A user gesture must be registered before audio can be played.\n * This Array contains the Sound instances which are requested for playback prior to a gesture.\n * Once a gesture is observed, we begin playing all elements of this Array.\n * @see Sound\n * @defaultValue `[]`\n */\npending:(()=>void)[];/**\n * A flag for whether video playback is currently locked by awaiting a user gesture\n * @defaultValue `true`\n */\nlocked:boolean;/**\n * Audio Context singleton used for analysing audio levels of each stream\n * Only created if necessary to listen to audio streams.\n * @defaultValue `null`\n * @internal\n */protected _audioContext:AudioContext|null;/**\n * Map of all streams that we listen to for determining the decibel levels.\n * Used for analyzing audio levels of each stream.\n * Format of the object stored is :\n * ```\n * {id:\n *   {\n *     stream: MediaStream,\n *     analyser: AudioAnalyser,\n *     interval: Number,\n *     callback: Function\n *   }\n * }\n * ```\n * @internal\n */protected _analyserStreams:Record<string,AudioHelper.AnalyserStream>;/**\n * Interval ID as returned by setInterval for analysing the volume of streams\n * When set to 0, means no timer is set.\n * @defaultValue `0`\n * @internal\n */protected _analyserInterval:number;/**\n * Fast Fourier Transform Array.\n * Used for analysing the decibel level of streams. The array is allocated only once\n * then filled by the analyser repeatedly. We only generate it when we need to listen to\n * a stream's level, so we initialize it to null.\n * @defaultValue `null`\n * @internal\n */protected _fftArray:Float32Array|null;/**\n * The Native interval for the AudioHelper to analyse audio levels from streams\n * Any interval passed to startLevelReports() would need to be a multiple of this value.\n * @defaultValue `50`\n */static levelAnalyserNativeInterval:number;/**\n * Register client-level settings for global volume overrides\n */static registerSettings():void;/**\n * Create a Sound instance for a given audio source URL\n * @param options - Audio creation options\n */\ncreate(options:AudioHelper.CreateOptions):Sound;/**\n * Test whether a source file has a supported audio extension type\n * @param src - A requested audio source path\n * @returns Does the filename end with a valid audio extension?\n */static hasAudioExtension(src:string):boolean;/**\n * Given an input file path, determine a default name for the sound based on the filename\n * @param src - An input file path\n * @returns A default sound name for the path\n */static getDefaultSoundName(src:string):string;/**\n * Play a single Sound by providing its source.\n * @param src     - The file path to the audio source being played\n * @param options - Additional options passed to Sound#play\n * @returns The created Sound which is now playing\n */\nplay(src:string,options?:Sound.PlayOptions):Promise<Sound>;/**\n * Register an event listener to await the first mousemove gesture and begin playback once observed\n */\nawaitFirstGesture():void;/**\n * Request that other connected clients begin preloading a certain sound path.\n * @param src - The source file path requested for preload\n * @returns A Promise which resolves once the preload is complete\n */\npreload(src:string):Promise<Sound>;/**\n * Open socket listeners which transact ChatMessage data\n * @internal\n */static _activateSocketListeners(socket:io.Socket):void;/**\n * Play a one-off sound effect which is not part of a Playlist\n *\n * @param data - An object configuring the audio data to play\n * @param push - Push the audio sound effect to other connected clients?\n *               (default: `false`)\n *\n * @returns A Sound instance which controls audio playback.\n *\n * @example\n * ```typescript\n * // Play the sound of a locked door for all players\n * AudioHelper.play({src: \"sounds/lock.wav\", volume: 0.8, loop: false}, true);\n * ```\n */static play(data:AudioHelper.PlayData,push?:boolean):Promise<Sound>;/**\n * Begin loading the sound for a provided source URL adding its\n * @param src - The audio source path to preload\n * @returns The created and loaded Sound ready for playback\n */static preloadSound(src:string):Promise<Sound>;/**\n * Returns the volume value based on a range input volume control's position.\n * This is using an exponential approximation of the logarithmic nature of audio level perception\n * @param value - Value between [0, 1] of the range input\n * @param order - The exponent of the curve\n *                (default: `1.5`)\n */static inputToVolume(value:number|string,order?:number):number;/**\n * Counterpart to inputToVolume()\n * Returns the input range value based on a volume\n * @param volume - Value between [0, 1] of the volume level\n * @param order  - The exponent of the curve\n */static volumeToInput(volume:number,order?:number):number;/**\n * Returns a singleton AudioContext if one can be created.\n * An audio context may not be available due to limited resources or browser compatibility\n * in which case null will be returned\n *\n * @returns A singleton AudioContext or null if one is not available\n */\ngetAudioContext():AudioContext|null;/**\n * Registers a stream for periodic reports of audio levels.\n * Once added, the callback will be called with the maximum decibel level of\n * the audio tracks in that stream since the last time the event was fired.\n * The interval needs to be a multiple of `AudioHelper.levelAnalyserNativeInterval` which defaults at 50ms\n *\n * @param id        - An id to assign to this report. Can be used to stop reports\n * @param stream    - The MediaStream instance to report activity on.\n * @param callback  - The callback function to call with the decibel level.\n * @param interval  - The interval at which to produce reports.\n *                    (default: `50`)\n * @param smoothing - The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.\n *                    (default: `0.1`)\n * @returns Returns whether or not listening to the stream was successful\n */\nstartLevelReports(id:string,stream:MediaStream,callback:(maxDecibel:number,fftArray:Float32Array)=>void,interval?:number,smoothing?:number):boolean|undefined;/**\n * Stop sending audio level reports\n * This stops listening to a stream and stops sending reports.\n * If we aren't listening to any more streams, cancel the global analyser timer.\n * @param id - The id of the reports that passed to startLevelReports.\n */\nstopLevelReports(id:string):void;/**\n * Ensures the global analyser timer is started\n *\n * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things\n * and avoid having multiple timers running if we want to analyse multiple streams at the same time.\n * I don't know if it actually helps much with performance but it's expected that limiting the number of timers\n * running at the same time is good practice and with JS itself, there's a potential for a timer congestion\n * phenomenon if too many are created.\n * @internal\n */protected _ensureAnalyserTimer():void;/**\n * Cancel the global analyser timer\n * If the timer is running and has become unnecessary, stops it.\n * @internal\n */protected _cancelAnalyserTimer():void;/**\n * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels\n * detected since the last emit.\n * The event's detail is in the form of `{userId: decibelLevel}`\n * @internal\n */protected _emitVolumes():void;/**\n * Handle the first observed user gesture\n * @param event - The mouse-move event which enables playback\n * @internal\n */protected _onFirstGesture(event:Event):void;/**\n * Additional standard callback events that occur whenever a global volume slider is adjusted\n * @param key    - The setting key\n * @param volume - The new volume level\n * @internal\n */protected _onChangeGlobalVolume(key:string,volume:number):void;}declare namespace AudioHelper{interface AnalyserStream{stream:MediaStream;analyser:AnalyserNode;interval:number;callback:(maxDecibel:number,fftArray:Float32Array)=>void;/**\n * Used as a counter of 50ms increments in case the interval is more than 50\n * @defaultValue `0`\n * @internal\n */\n_lastEmit:number;}interface CreateOptions{/**\n * The source URL for the audio file\n */\nsrc:string;/**\n * Reuse an existing Sound for this source?\n * @defaultValue `true`\n */\nsingleton?:boolean;/**\n * Begin loading the audio immediately?\n * @defaultValue `false`\n */\npreload?:boolean;/**\n * Begin playing the audio as soon as it is ready?\n * @defaultValue `false`\n */\nautoplay?:boolean;/**\n * Additional options passed to the play method if autoplay is true\n * @defaultValue `{}`\n */\nautoplayOptions?:Sound.PlayOptions;}interface PlayData{/**\n * The audio source file path, either a public URL or a local path relative to the public directory\n */\nsrc:string;/**\n * The volume level at which to play the audio, between 0 and 1.\n * @defaultValue `1.0`\n */\nvolume?:number;/**\n * Begin playback of the audio effect immediately once it is loaded.\n * @deprecated You are using the autoplay option of AudioHelper.play which is no longer supported in 0.8.0\n */\nautoplay?:boolean;/**\n * Loop the audio effect and continue playing it until it is manually stopped.\n * @defaultValue `false`\n */\nloop?:boolean;}}"
    ]
  